"""
Autonomous Pentesting Assistant - No hardcoded patterns, semantic reasoning.

Replaces rigid methodology enforcement with intelligent, context-aware pentesting.
Features:
- Semantic understanding of user intent and context
- Autonomous reasoning about attack surfaces
- Dynamic command generation (not from templates)
- Natural conversation flow without loops
- Complete metasploit integration
- Session and listener management
"""

import logging
import re
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from spectral.exploitation_reasoner import ExploitationPlan, ExploitationReasoner
from spectral.llm_client import LLMClient
from spectral.metasploit_executor import ExploitResult, MetasploitExecutor, PayloadType

logger = logging.getLogger(__name__)


class ConversationStage(Enum):
    """Stages of conversation, but not enforced methodology."""

    INITIAL = "initial"
    UNDERSTANDING = "understanding"
    PLANNING = "planning"
    EXECUTING = "executing"
    POST_EXPLOITATION = "post_exploitation"
    CLARIFICATION = "clarification"


@dataclass
class TargetContext:
    """Context about the current target being tested."""

    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    os_type: Optional[str] = None
    os_version: Optional[str] = None
    architecture: Optional[str] = None
    services: List[str] = field(default_factory=list)
    open_ports: List[int] = field(default_factory=list)
    service_versions: Dict[str, str] = field(default_factory=dict)
    credentials: List[Dict[str, str]] = field(default_factory=list)
    network_location: Optional[str] = None
    access_level: Optional[str] = None
    cves: List[str] = field(default_factory=list)
    known_vulnerabilities: List[str] = field(default_factory=list)
    authorized: Optional[bool] = None

    # Context persistence
    last_updated: Optional[str] = None
    information_source: Optional[str] = None  # "user_provided", "scanned", "inferred"


@dataclass
class ExecutionContext:
    """Context about current execution state."""

    active_sessions: Dict[str, Any] = field(default_factory=dict)
    active_listeners: Dict[str, Any] = field(default_factory=dict)
    current_stage: ConversationStage = ConversationStage.INITIAL
    previous_commands: List[str] = field(default_factory=list)
    execution_history: List[Dict[str, Any]] = field(default_factory=list)
    reasoning_trace: List[str] = field(default_factory=list)


class AutonomousPentestingAssistant:
    """
    Autonomous pentesting assistant with semantic understanding.

    Key differences from old version:
    - NO hardcoded question templates
    - NO forced methodology stages
    - Semantic understanding of context
    - Autonomous reasoning and decision-making
    - Natural conversation flow
    """

    def __init__(
        self,
        llm_client: Optional[LLMClient] = None,
        metasploit_executor: Optional[MetasploitExecutor] = None,
        exploitation_reasoner: Optional[ExploitationReasoner] = None,
        semantic_classifier=None,
    ) -> None:
        """
        Initialize the autonomous pentesting assistant.

        Args:
            llm_client: LLM for semantic reasoning and conversation
            metasploit_executor: Executor for metasploit commands
            exploitation_reasoner: Reasoner for exploit selection
            semantic_classifier: Semantic intent classifier
        """
        self.llm_client = llm_client
        self.metasploit_executor = metasploit_executor or MetasploitExecutor()
        self.exploitation_reasoner = exploitation_reasoner or ExploitationReasoner(
            llm_client
        )
        self.semantic_classifier = semantic_classifier

        # Context management
        self.target_context: Optional[TargetContext] = None
        self.execution_context: ExecutionContext = ExecutionContext()
        self.conversation_history: List[Dict[str, str]] = []

        logger.info("AutonomousPentestingAssistant initialized")

    def handle_request(self, user_message: str) -> str:
        """
        Handle a pentesting request with autonomous reasoning.

        This is the main entry point - no hardcoded patterns or templates.

        Args:
            user_message: User's request

        Returns:
            AI's response based on semantic understanding
        """
        logger.info(f"Received request: {user_message}")

        # Add to conversation history
        self.conversation_history.append({"role": "user", "content": user_message})

        # Check for context clearing
        if self._is_context_clear_command(user_message):
            self._clear_all_context()
            response = (
                "Context cleared. Ready for a new target. What would you like to test?"
            )
        else:
            # Update context from user message
            self._update_context_from_message(user_message)

            # Generate autonomous response
            response = self._generate_autonomous_response(user_message)

        # Add AI response to history
        self.conversation_history.append({"role": "assistant", "content": response})

        return response

    def _is_context_clear_command(self, user_message: str) -> bool:
        """Check if user wants to clear context."""
        clear_patterns = [
            r"\bforget\b",
            r"\bclear\b.*\bcontext\b",
            r"\bnew target\b",
            r"\bdifferent machine\b",
            r"\breset\b",
            r"\bstart over\b",
        ]
        return any(
            re.search(pattern, user_message, re.IGNORECASE)
            for pattern in clear_patterns
        )

    def _clear_all_context(self) -> None:
        """Clear all context."""
        self.target_context = None
        self.execution_context = ExecutionContext()
        self.conversation_history.clear()
        logger.info("All context cleared")

    def _update_context_from_message(self, user_message: str) -> None:
        """Update context from user message using semantic understanding."""

        # Initialize target context if needed
        if not self.target_context:
            self.target_context = TargetContext()
            self.target_context.last_updated = str(time.time())
            self.target_context.information_source = "user_provided"

        # Parse information using semantic understanding
        parsed_info = self._semantic_parse_information(user_message)

        # Update target context with new information
        for key, value in parsed_info.items():
            if hasattr(self.target_context, key):
                old_value = getattr(self.target_context, key)

                # Handle list fields specially
                if isinstance(value, list) and isinstance(old_value, list):
                    # Merge lists, avoiding duplicates
                    combined = list(set(old_value + value))
                    setattr(self.target_context, key, combined)
                else:
                    # Replace single values
                    setattr(self.target_context, key, value)

                logger.info(f"Updated target context: {key} = {value}")

        self.target_context.last_updated = str(time.time())

    def _semantic_parse_information(self, user_message: str) -> Dict[str, Any]:
        """Parse information from user message using semantic understanding."""
        info = {}
        message_lower = user_message.lower()

        # IP address detection
        ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
        ip_match = re.search(ip_pattern, user_message)
        if ip_match:
            new_ip = ip_match.group()
            # Check if this is a different IP (context change)
            if self.target_context and self.target_context.ip_address != new_ip:
                logger.info(f"IP address change detected: {new_ip}")
                self._clear_execution_context()  # Clear execution when target changes
            info["ip_address"] = new_ip

        # OS detection with semantic understanding
        os_mappings = {
            r"\bwindows\s*(\d+)": ("Windows", "os_version"),
            r"\bwindows\s*10\b": ("Windows", "10"),
            r"\bwindows\s*11\b": ("Windows", "11"),
            r"\bwindows\s*server\s*(\d+)\b": ("Windows Server", None),
            r"\bwindows\b": ("Windows", None),
            r"\blinux\b": ("Linux", None),
            r"\bubuntu\s+([\d.]+)\b": ("Ubuntu", None),
            r"\bcentos\b": ("CentOS", None),
            r"\bdebian\b": ("Debian", None),
            r"\bmacos\b": ("macOS", None),
            r"\bmac\b": ("macOS", None),
            r"\bandroid\b": ("Android", None),
            r"\bios\b": ("iOS", None),
        }

        for pattern, (os_name, version_field) in os_mappings.items():
            match = re.search(pattern, message_lower)
            if match:
                info["os_type"] = os_name
                if version_field and match.groups():
                    info[version_field] = match.group(1)
                break

        # Service and port detection
        service_mappings = {
            "ssh": 22,
            "rdp": 3389,
            "smb": 445,
            "http": 80,
            "https": 443,
            "ftp": 21,
            "telnet": 23,
            "mysql": 3306,
            "postgresql": 5432,
            "mongodb": 27017,
            "redis": 6379,
            "vnc": 5900,
            "nfs": 2049,
            "dns": 53,
            "smtp": 25,
            "winrm": 5985,
        }

        for service, port in service_mappings.items():
            if service in message_lower:
                if "services" not in info:
                    info["services"] = []
                if service.upper() not in info["services"]:
                    info["services"].append(service.upper())

                if "open_ports" not in info:
                    info["open_ports"] = []
                if port not in info["open_ports"]:
                    info["open_ports"].append(port)

        # Credential detection
        credential_patterns = [
            r"\b(\w+):(\w+)\b",  # username:password
            r"\buser[:\s]+(\w+)[\s,:]+pass[:\s]+(\w+)\b",  # user: pass format
        ]

        for pattern in credential_patterns:
            matches = re.findall(pattern, message_lower)
            for match in matches:
                if isinstance(match, tuple) and len(match) == 2:
                    username, password = match
                    if "credentials" not in info:
                        info["credentials"] = []
                    info["credentials"].append(
                        {
                            "username": username,
                            "password": password,
                            "source": "user_provided",
                        }
                    )

        # Authorization detection
        auth_patterns = {
            r"\bauthorized\b": True,
            r"\bmy\s+lab\b": True,
            r"\bpermission\b": True,
            r"\bwith\s+consent\b": True,
            r"\bunauthorized\b": False,
            r"\bno\s+permission\b": False,
        }

        for pattern, status in auth_patterns.items():
            if re.search(pattern, message_lower):
                info["authorized"] = status
                break

        # Network location detection
        network_patterns = ["internal", "dmz", "external"]
        for network in network_patterns:
            if network in message_lower:
                info["network_location"] = network.title()
                break

        # Access level detection
        access_patterns = {
            r"\badmin\b": "admin",
            r"\badministrator\b": "admin",
            r"\broot\b": "admin",
            r"\buser\b": "user",
            r"\bno\s+access\b": "unauthenticated",
        }

        for pattern, access_level in access_patterns.items():
            if re.search(pattern, message_lower):
                info["access_level"] = access_level
                break

        return info

    def _clear_execution_context(self) -> None:
        """Clear execution context when target changes."""
        self.execution_context = ExecutionContext()
        logger.info("Execution context cleared due to target change")

    def _generate_autonomous_response(self, user_message: str) -> str:
        """
        Generate autonomous response using semantic understanding.

        This replaces hardcoded templates with intelligent reasoning.
        """

        # If no target context, ask for basic info naturally
        if not self.target_context or not self.target_context.ip_address:
            return self._handle_initial_request(user_message)

        # If we have target context, analyze what the user wants
        intent_analysis = self._analyze_user_intent(user_message)

        if intent_analysis["needs_clarification"]:
            return self._ask_natural_clarification(intent_analysis["missing_info"])

        # Route based on intent
        intent = intent_analysis["intent"]

        if intent == "reconnaissance":
            return self._handle_reconnaissance_request(user_message)
        elif intent == "exploitation":
            return self._handle_exploitation_request(user_message)
        elif intent == "post_exploitation":
            return self._handle_post_exploitation_request(user_message)
        elif intent == "status_check":
            return self._handle_status_request(user_message)
        else:
            return self._handle_conversational_request(user_message)

    def _analyze_user_intent(self, user_message: str) -> Dict[str, Any]:
        """Analyze user intent using semantic understanding."""

        message_lower = user_message.lower()

        # Intent keywords (semantic, not just exact matches)
        reconnaissance_intents = [
            "scan",
            "enumerate",
            "discover",
            "find",
            "detect",
            "nmap",
            "ping",
            "port scan",
            "service scan",
        ]

        exploitation_intents = [
            "exploit",
            "attack",
            "compromise",
            "get shell",
            "gain access",
            "payload",
            "metasploit",
            "msfconsole",
            "msfvenom",
        ]

        post_exploitation_intents = [
            "privilege",
            "escalate",
            "persistence",
            "maintain access",
            "lateral movement",
            "pivot",
            "dump",
            "mimikatz",
        ]

        status_intents = [
            "status",
            "sessions",
            "listeners",
            "what's running",
            "current state",
            "active",
        ]

        # Check for each intent type
        if any(intent_word in message_lower for intent_word in reconnaissance_intents):
            intent = "reconnaissance"
        elif any(intent_word in message_lower for intent_word in exploitation_intents):
            intent = "exploitation"
        elif any(
            intent_word in message_lower for intent_word in post_exploitation_intents
        ):
            intent = "post_exploitation"
        elif any(intent_word in message_lower for intent_word in status_intents):
            intent = "status_check"
        else:
            intent = "conversational"

        # Determine what's missing for this intent
        missing_info = self._determine_missing_information(intent)

        needs_clarification = len(missing_info) > 0 and any(
            info in missing_info for info in ["ip_address", "authorization"]
        )

        return {
            "intent": intent,
            "missing_info": missing_info,
            "needs_clarification": needs_clarification,
        }

    def _determine_missing_information(self, intent: str) -> List[str]:
        """Determine what information is missing for the given intent."""
        if not self.target_context:
            return ["ip_address"]

        missing = []

        # Critical missing information
        if not self.target_context.ip_address:
            missing.append("ip_address")

        if intent in ["exploitation", "post_exploitation"]:
            if self.target_context.authorized is None:
                missing.append("authorization")

            # For exploitation, we prefer to have some service info
            if not self.target_context.services and not self.target_context.open_ports:
                missing.append("service_information")

        return missing

    def _handle_initial_request(self, user_message: str) -> str:
        """Handle initial request when no target context exists."""

        # Natural conversation - not a template
        response_parts = []

        # Acknowledge the request naturally
        if any(word in user_message.lower() for word in ["help", "how", "what"]):
            response_parts.append(
                "I can help you with penetration testing tasks. I can scan targets, enumerate services, and exploit vulnerabilities using Metasploit."
            )

        # Ask for what's needed naturally
        response_parts.append("To get started, I'll need:")

        needed_items = []
        if not self.target_context or not self.target_context.ip_address:
            needed_items.append("the target IP address")

        if not self.target_context or self.target_context.authorized is None:
            needed_items.append("confirmation this is authorized testing")

        if needed_items:
            response_parts.append("• " + "\n• ".join(needed_items))

        response_parts.append(
            "Just provide the IP address and let me know this is your lab or you have permission to test it."
        )

        return "\n".join(response_parts)

    def _ask_natural_clarification(self, missing_info: List[str]) -> str:
        """Ask for clarification in natural language, not templates."""

        if "ip_address" in missing_info:
            return "What's the IP address of the target you'd like me to test?"

        if "authorization" in missing_info:
            return "Is this your lab or do you have explicit permission to test this target?"

        if "service_information" in missing_info:
            return "Do you know what services are running on the target, or should I scan it first?"

        return "I need a bit more information to help you effectively."

    def _handle_reconnaissance_request(self, user_message: str) -> str:
        """Handle reconnaissance requests autonomously."""

        if not self.target_context or not self.target_context.ip_address:
            return "I need a target IP address before I can scan it."

        # Check authorization
        if self.target_context.authorized is False:
            return "⚠️ I cannot assist with unauthorized testing."

        # Determine scan type from user message
        scan_type = "basic"
        if any(
            word in user_message.lower() for word in ["version", "detailed", "full"]
        ):
            scan_type = "detailed"
        elif any(word in user_message.lower() for word in ["quick", "fast", "basic"]):
            scan_type = "basic"

        # Execute the scan
        return self._execute_reconnaissance(scan_type)

    def _execute_reconnaissance(self, scan_type: str) -> str:
        """Execute reconnaissance based on scan type."""

        if not self.target_context or not self.target_context.ip_address:
            return "No target IP address available."

        ip = self.target_context.ip_address

        # Build nmap command based on scan type
        if scan_type == "detailed":
            command = f"nmap -sV -sC -O {ip}"
        else:
            command = f"nmap -F {ip}"  # Fast scan

        # Execute the command
        try:
            result = self.metasploit_executor.execute_command(command, timeout=120)

            # Update context with scan results
            if result.exit_code == 0:
                self._parse_scan_results(result.stdout)
                self.execution_context.previous_commands.append(command)

                response = f"✅ Scan complete for {ip}\n\n"
                response += f"**Command:** `{command}`\n\n"
                response += f"**Results:**\n```\n{result.stdout}\n```"

                # Add context about what was found
                if self.target_context.services:
                    response += f"\n\n**Identified Services:** {', '.join(self.target_context.services)}"

                return response
            else:
                return f"❌ Scan failed: {result.stderr}"

        except Exception as e:
            return f"❌ Error during reconnaissance: {str(e)}"

    def _parse_scan_results(self, output: str) -> None:
        """Parse nmap scan results to update target context."""
        if not self.target_context:
            return

        # Parse open ports
        port_pattern = r"(\d+)/(tcp|udp)\s+open\s+([^\s]+)(?:\s+(.*))?"
        matches = re.findall(port_pattern, output)

        for port, proto, service, version in matches:
            port_int = int(port)
            if port_int not in self.target_context.open_ports:
                self.target_context.open_ports.append(port_int)

            service_upper = service.upper()
            if service_upper not in self.target_context.services:
                self.target_context.services.append(service_upper)

            if version:
                self.target_context.service_versions[service_upper] = version.strip()

        # Parse OS information
        if "Service Info: OS:" in output:
            os_match = re.search(r"Service Info: OS: (.*?);", output)
            if os_match:
                os_info = os_match.group(1).split()
                if os_info:
                    self.target_context.os_type = os_info[0]
                    if len(os_info) > 1:
                        self.target_context.os_version = " ".join(os_info[1:])

    def _handle_exploitation_request(self, user_message: str) -> str:
        """Handle exploitation requests with autonomous reasoning."""

        # Check if we have enough information
        if not self.target_context or not self.target_context.ip_address:
            return "I need a target IP address before I can attempt exploitation."

        if self.target_context.authorized is False:
            return "⚠️ I cannot assist with unauthorized exploitation."

        # Use the exploitation reasoner to plan the attack
        return self._plan_and_execute_exploitation()

    def _plan_and_execute_exploitation(self) -> str:
        """Plan and execute exploitation using autonomous reasoning."""

        if not self.target_context:
            return "No target context available."

        # Convert target context to dict for reasoning
        target_info = {
            "ip": self.target_context.ip_address,
            "hostname": self.target_context.hostname,
            "os_type": self.target_context.os_type,
            "os_version": self.target_context.os_version,
            "architecture": self.target_context.architecture,
            "services": self.target_context.services,
            "open_ports": self.target_context.open_ports,
            "service_versions": self.target_context.service_versions,
            "network_location": self.target_context.network_location,
            "access_level": self.target_context.access_level,
            "cves": self.target_context.cves,
            "known_vulnerabilities": self.target_context.known_vulnerabilities,
        }

        try:
            # Get exploitation plan from reasoner
            plan = self.exploitation_reasoner.reason_about_target(
                target_info,
                available_credentials=self.target_context.credentials,
                network_context=self.target_context.network_location,
            )

            # Execute the plan
            return self._execute_exploitation_plan(plan)

        except Exception as e:
            logger.error(f"Exploitation planning failed: {e}")
            return f"❌ Error planning exploitation: {str(e)}"

    def _execute_exploitation_plan(self, plan: ExploitationPlan) -> str:
        """Execute the exploitation plan with live feedback."""

        response = f"**Exploitation Plan for {plan.target_summary}**\n\n"
        response += f"{plan.reasoning_summary}\n\n"
        response += "---\n\n"

        # Execute attack chain
        for i, exploit in enumerate(plan.attack_chain, 1):
            response += f"**Step {i}: {exploit.name}**\n"
            response += f"Description: {exploit.description}\n"
            response += f"Success Probability: {exploit.success_probability:.0%}\n"
            response += f"Risk Level: {exploit.risk_level.value.title()}\n"

            if exploit.modules:
                response += f"Metasploit Module: {exploit.modules[0]}\n"

            if exploit.commands:
                response += f"Command: `{exploit.commands[0]}`\n"

            response += f"Reasoning: {exploit.reasoning}\n\n"

            # Execute the exploit if we have commands
            if exploit.commands and exploit.success_probability > 0.3:
                command = exploit.commands[0]
                try:
                    result = self.metasploit_executor.execute_command(
                        command, timeout=180
                    )

                    if result.exit_code == 0:
                        response += f"✅ **Execution Successful**\n"
                        response += f"```\n{result.stdout[:500]}...\n```\n\n"

                        # Update execution context
                        self.execution_context.previous_commands.append(command)
                        self.execution_context.execution_history.append(
                            {
                                "exploit": exploit.name,
                                "command": command,
                                "success": True,
                                "output": result.stdout,
                                "timestamp": str(time.time()),
                            }
                        )
                    else:
                        response += f"❌ **Execution Failed**\n"
                        response += f"Error: {result.stderr}\n\n"

                        self.execution_context.execution_history.append(
                            {
                                "exploit": exploit.name,
                                "command": command,
                                "success": False,
                                "error": result.stderr,
                                "timestamp": str(time.time()),
                            }
                        )

                except Exception as e:
                    response += f"❌ **Execution Error**: {str(e)}\n\n"

        # Add session information if available
        sessions = self.metasploit_executor.get_active_sessions()
        if sessions:
            response += "**Active Sessions:**\n"
            for session_id, session in sessions.items():
                response += f"• Session {session_id}: {session.session_type} to {session.target_ip}\n"
            response += "\n"

        return response

    def _handle_post_exploitation_request(self, user_message: str) -> str:
        """Handle post-exploitation requests."""

        sessions = self.metasploit_executor.get_active_sessions()
        if not sessions:
            return "No active sessions found. You need to gain access first before doing post-exploitation."

        # Determine what post-exploitation action is requested
        message_lower = user_message.lower()

        if "privilege" in message_lower or "escalat" in message_lower:
            return self._handle_privilege_escalation()
        elif "persistence" in message_lower:
            return self._handle_persistence_setup()
        elif "dump" in message_lower or "credential" in message_lower:
            return self._handle_credential_dumping()
        elif "lateral" in message_lower or "pivot" in message_lower:
            return self._handle_lateral_movement()
        else:
            return "What post-exploitation action would you like me to perform? I can help with privilege escalation, persistence, credential dumping, or lateral movement."

    def _handle_privilege_escalation(self) -> str:
        """Handle privilege escalation requests."""
        return "Privilege escalation depends on the target OS and current access level. What specific privilege escalation technique are you looking for?"

    def _handle_persistence_setup(self) -> str:
        """Handle persistence setup requests."""
        return "I can help establish persistence on the compromised system. What type of persistence mechanism would you prefer?"

    def _handle_credential_dumping(self) -> str:
        """Handle credential dumping requests."""
        return "I can help dump credentials from the compromised system. This requires an active meterpreter session."

    def _handle_lateral_movement(self) -> str:
        """Handle lateral movement requests."""
        return "I can help with lateral movement to other systems on the network. Do you have other targets identified?"

    def _handle_status_request(self, user_message: str) -> str:
        """Handle status check requests."""

        sessions = self.metasploit_executor.get_active_sessions()
        listeners = self.metasploit_executor.get_active_listeners()

        response = "**Current Status:**\n\n"

        # Target information
        if self.target_context:
            response += f"**Target:** {self.target_context.ip_address}\n"
            if self.target_context.os_type:
                response += f"**OS:** {self.target_context.os_type} {self.target_context.os_version or ''}\n"
            if self.target_context.services:
                response += f"**Services:** {', '.join(self.target_context.services)}\n"
            response += "\n"

        # Active sessions
        if sessions:
            response += f"**Active Sessions:** {len(sessions)}\n"
            for session_id, session in sessions.items():
                response += f"  • Session {session_id}: {session.session_type} to {session.target_ip}\n"
        else:
            response += "**Active Sessions:** None\n"
        response += "\n"

        # Active listeners
        if listeners:
            response += f"**Active Listeners:** {len(listeners)}\n"
            for listener_id, listener in listeners.items():
                response += (
                    f"  • {listener.payload} on {listener.lhost}:{listener.lport}\n"
                )
        else:
            response += "**Active Listeners:** None\n"
        response += "\n"

        # Recent commands
        if self.execution_context.previous_commands:
            response += f"**Recent Commands:** {len(self.execution_context.previous_commands)}\n"
            for cmd in self.execution_context.previous_commands[-5:]:  # Last 5 commands
                response += f"  • {cmd}\n"

        return response

    def _handle_conversational_request(self, user_message: str) -> str:
        """Handle general conversational requests."""

        # Use LLM if available for natural conversation
        if self.llm_client:
            try:
                prompt = f"""You are a helpful penetration testing assistant. The user said: "{user_message}"

Current context:
- Target: {self.target_context.ip_address if self.target_context else 'None'}
- Recent commands: {len(self.execution_context.previous_commands) if self.execution_context else 0}
- Active sessions: {len(self.metasploit_executor.get_active_sessions()) if self.metasploit_executor else 0}

Respond naturally and helpfully to the user's message."""

                response = self.llm_client.generate(prompt, max_tokens=200)
                return response

            except Exception as e:
                logger.error(f"LLM conversation failed: {e}")

        # Fallback response
        return f"I understand you're asking about '{user_message}'. How can I help with your penetration testing?"

    def get_target_summary(self) -> str:
        """Get a formatted summary of current target information."""
        if not self.target_context:
            return "No target information available."

        parts = []

        if self.target_context.ip_address:
            parts.append(f"IP: {self.target_context.ip_address}")
        if self.target_context.hostname:
            parts.append(f"Hostname: {self.target_context.hostname}")
        if self.target_context.os_type:
            os_str = f"OS: {self.target_context.os_type}"
            if self.target_context.os_version:
                os_str += f" {self.target_context.os_version}"
            parts.append(os_str)
        if self.target_context.services:
            parts.append(f"Services: {', '.join(self.target_context.services)}")
        if self.target_context.network_location:
            parts.append(f"Network: {self.target_context.network_location}")
        if self.target_context.authorized is not None:
            parts.append(
                f"Authorized: {'Yes' if self.target_context.authorized else 'No'}"
            )

        return (
            "\n".join(f"• {part}" for part in parts)
            if parts
            else "• No target info yet"
        )

    def update_target_info(self, field: str, value: Any) -> None:
        """Update specific target field."""
        if not self.target_context:
            self.target_context = TargetContext()

        if hasattr(self.target_context, field):
            setattr(self.target_context, field, value)
            logger.info(f"Updated target {field}: {value}")

    def handle_pentest_request(self, user_input: str) -> str:
        """
        Handle a penetration testing request from user input.

        This method provides backward compatibility with the old PentestingAssistant
        interface by delegating to the autonomous request handler.

        Args:
            user_input: The user's request

        Returns:
            Response string
        """
        logger.info(f"Handling pentest request: {user_input}")
        return self.handle_request(user_input)
