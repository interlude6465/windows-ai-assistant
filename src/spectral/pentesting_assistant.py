"""
Pentesting Assistant - Conversational Pentesting Methodology Layer.

Enforces systematic methodology with NO hardcoded shortcuts:
- ALWAYS asks clarifying questions FIRST
- Code only generates AFTER methodology is clear
- Autonomous execution when info is sufficient
- Context-aware and persistent across turns

Methodology Stages:
1. RECONNAISSANCE: Gather basic target info (IP, OS type)
2. ENUMERATION: Discover services, ports, versions
3. VULNERABILITY_ASSESSMENT: Research CVEs and exploits
4. METHODOLOGY_SELECTION: Choose exploitation approach
5. EXPLOITATION: Execute chosen method
6. POST_EXPLOITATION: Maintain access, escalate privileges

Key Rules:
- NEVER generate payloads instantly - ask 5+ clarifying questions first
- NEVER try code execution without understanding methodology
- ALWAYS explain exploitation path before generating code
- ASK about delivery method, callback type, target network, obfuscation
- PRIORITIZE methodology reasoning over instant code generation
"""

import logging
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

from spectral.llm_client import LLMClient

logger = logging.getLogger(__name__)


class ExploitStage(Enum):
    """Stages of penetration testing engagement."""

    RECONNAISSANCE = "reconnaissance"
    ENUMERATION = "enumeration"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    METHODOLOGY_SELECTION = "methodology_selection"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"


@dataclass
class TargetInfo:
    """Information about the penetration test target."""

    ip_address: Optional[str] = None
    hostname: Optional[str] = None
    os_type: Optional[str] = None  # Windows, Linux, macOS, Android, iOS
    os_version: Optional[str] = None  # 10, 11, 20.04, etc.
    architecture: Optional[str] = None  # x86, x64, ARM, etc.
    services: List[str] = field(default_factory=list)
    open_ports: List[int] = field(default_factory=list)
    service_versions: Dict[str, str] = field(default_factory=dict)
    credentials: List[Dict[str, str]] = field(default_factory=list)
    network_location: Optional[str] = None  # Internal, DMZ, External
    access_level: Optional[str] = None  # Unauthenticated, User, Admin
    cves: List[str] = field(default_factory=list)
    known_vulnerabilities: List[str] = field(default_factory=list)
    authorized: Optional[bool] = None  # Is this authorized testing?

    def to_summary(self) -> str:
        """Generate a human-readable summary of target info."""
        parts = []

        if self.ip_address:
            parts.append(f"IP: {self.ip_address}")
        if self.hostname:
            parts.append(f"Hostname: {self.hostname}")
        if self.os_type:
            os_str = f"OS: {self.os_type}"
            if self.os_version:
                os_str += f" {self.os_version}"
            parts.append(os_str)
        if self.architecture:
            parts.append(f"Arch: {self.architecture}")
        if self.services:
            parts.append(f"Services: {', '.join(self.services)}")
        if self.open_ports:
            parts.append(f"Ports: {', '.join(map(str, self.open_ports))}")
        if self.network_location:
            parts.append(f"Network: {self.network_location}")
        if self.access_level:
            parts.append(f"Access: {self.access_level}")
        if self.authorized is not None:
            parts.append(f"Authorized: {'Yes' if self.authorized else 'No'}")

        return "\n".join(f"  • {part}" for part in parts) if parts else "  No target info yet"


@dataclass
class ExploitMethodology:
    """Chosen exploitation methodology with parameters."""

    exploit_type: Optional[str] = None  # CVE, brute-force, default creds, etc.
    delivery_method: Optional[str] = None  # EXE, PowerShell, DLL, batch, macro, etc.
    callback_type: Optional[str] = None  # Reverse TCP, Reverse HTTPS, Bind shell, etc.
    obfuscation: Optional[bool] = None
    payload_format: Optional[str] = None  # exe, elf, apk, script, etc.
    staging_required: Optional[bool] = None
    risk_assessment: Optional[str] = None
    lhost: Optional[str] = None
    lport: Optional[str] = None
    answers: Dict[str, str] = field(
        default_factory=dict
    )  # Store specific answers to methodology questions


class PentestingAssistant:
    """
    Conversational pentesting assistant with enforced methodology.

    CRITICAL: NEVER use hardcoded shortcuts.
    ALWAYS ask clarifying questions FIRST.
    """

    def __init__(
        self,
        llm_client: LLMClient,
        research_handler=None,
        semantic_classifier=None,
        direct_executor=None,
    ) -> None:
        """
        Initialize the pentesting assistant.

        Args:
            llm_client: LLM for reasoning and conversation
            research_handler: Research handler for vulnerability lookups
            semantic_classifier: Semantic intent classifier
            direct_executor: Direct executor for running commands
        """
        self.llm_client = llm_client
        self.research_handler = research_handler
        self.semantic_classifier = semantic_classifier
        self.direct_executor = direct_executor

        self.target: Optional[TargetInfo] = None
        self.methodology: Optional[ExploitMethodology] = None
        self.stage = ExploitStage.RECONNAISSANCE
        self.conversation_history: List[Dict[str, str]] = []

        logger.info("PentestingAssistant initialized with methodology enforcement")

    def handle_pentest_request(self, user_message: str) -> str:
        """
        Handle a penetration testing request through intelligent conversation.

        This is the main entry point - enforced NO hardcoded shortcuts.

        Args:
            user_message: User's request (e.g., "test my Windows machine")

        Returns:
            AI's response (clarifying question, finding, or methodology explanation)
        """
        logger.info(f"Pentest request: {user_message}")

        # Check for context clear commands
        if self._is_context_clear_command(user_message):
            self._clear_context()
            return "Context cleared. Ready for a new target. What would you like to test?"

        # Parse user message for any target info
        self._parse_user_message(user_message)

        # Simple reconnaissance handling - execute directly if we have an IP
        if self.target and self.target.ip_address:
            recon_keywords = ["scan", "enumerate", "ports", "services", "nmap"]
            if any(kw in user_message.lower() for kw in recon_keywords):
                return self._handle_direct_recon(user_message)

        # Add to conversation history
        self.conversation_history.append({"role": "user", "content": user_message})

        # Determine current stage and what's needed
        response = self._stage_handler(user_message)

        # Add AI response to history
        self.conversation_history.append({"role": "assistant", "content": response})

        return response

    def _handle_direct_recon(self, user_message: str) -> str:
        """Handle simple reconnaissance directly."""
        if not self.target or not self.target.ip_address:
            return "I need a target IP address before I can run a scan."

        logger.info(f"Direct recon requested for {self.target.ip_address}")

        # If not authorized, ask first
        if self.target.authorized is None:
            return self._reconnaissance_stage(user_message)

        if self.target.authorized is False:
            return "⚠️ Reconnaissance blocked: Not authorized for this target."

        # Build nmap command
        options = "-F"
        if "version" in user_message.lower():
            options = "-sV"
        if "full" in user_message.lower():
            options = "-p-"

        cmd = f"nmap {options} {self.target.ip_address}"

        if self.direct_executor:
            try:
                logger.info(f"Executing recon command: {cmd}")
                # Use execute_metasploit_command as it's a general terminal executor
                exit_code, output = self.direct_executor.execute_metasploit_command(
                    cmd, show_terminal=True
                )

                # Parse output to update target info
                self._parse_nmap_output(output)

                return (
                    f"✅ Reconnaissance complete for {self.target.ip_address}\n\n"
                    f"**Command:** `{cmd}`\n\n**Output:**\n```\n{output}\n```"
                )
            except Exception as e:
                return f"❌ Error during reconnaissance: {str(e)}"

        return f"I would run `{cmd}` but no executor is available."

    def _parse_nmap_output(self, output: str) -> None:
        """Parse nmap output to update target info."""
        # Simple parsing for ports and services
        port_lines = re.findall(r"(\d+)/(tcp|udp)\s+open\s+([^\s]+)(?:\s+(.*))?", output)
        for port, proto, service, version in port_lines:
            port_int = int(port)
            if port_int not in self.target.open_ports:
                self.target.open_ports.append(port_int)
            if service.upper() not in self.target.services:
                self.target.services.append(service.upper())
            if version:
                self.target.service_versions[service.upper()] = version.strip()

        # Parse OS if available
        if "Service Info: OS:" in output:
            os_match = re.search(r"Service Info: OS: (.*?);", output)
            if os_match:
                self.target.os_type = os_match.group(1).split()[0]
                logger.info(f"OS identified from nmap: {self.target.os_type}")

    def _is_context_clear_command(self, user_message: str) -> bool:
        """Check if user wants to clear context."""
        clear_patterns = [
            r"\bforget\b",
            r"\bnew target\b",
            r"\bdifferent machine\b",
            r"\breset\b",
            r"\bclear\b.*\bcontext\b",
            r"\bstart over\b",
        ]
        return any(re.search(pattern, user_message, re.IGNORECASE) for pattern in clear_patterns)

    def _clear_context(self) -> None:
        """Clear all pentesting context."""
        self.target = None
        self.methodology = None
        self.stage = ExploitStage.RECONNAISSANCE
        self.conversation_history.clear()
        logger.info("Pentesting context cleared")

    def _stage_handler(self, user_message: str) -> str:
        """
        Route to appropriate stage handler based on what info we have.

        Enforces methodology by asking questions before moving to next stage.
        """
        # Route based on current stage and available info
        if not self.target or not self.target.ip_address or self.target.authorized is None:
            return self._reconnaissance_stage(user_message)

        elif not self.target.os_type or not self.target.os_version:
            return self._enumerate_os_stage(user_message)

        elif not self.target.services or not self.target.open_ports:
            return self._enumerate_services_stage(user_message)

        elif not self.methodology:
            return self._methodology_selection_stage(user_message)

        else:
            return self._exploitation_stage(user_message)

    def _parse_user_message(self, user_message: str) -> None:
        """Parse user message for target information."""
        # Initialize target if needed
        if not self.target:
            self.target = TargetInfo()

        # Parse IP address
        ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
        ip_match = re.search(ip_pattern, user_message)
        if ip_match:
            new_ip = ip_match.group()
            if self.target.ip_address and self.target.ip_address != new_ip:
                logger.info(f"Target IP changed from {self.target.ip_address} to {new_ip}")
                self._clear_context()
                self.target = TargetInfo()
            self.target.ip_address = new_ip
            logger.info(f"Target IP identified: {self.target.ip_address}")

        # Parse authorization
        auth_patterns = {
            r"\bauthorized\b": True,
            r"\bmy\s+lab\b": True,
            r"\bpermission\b": True,
            r"\bwith\s+consent\b": True,
            r"\bauthorized\s*:\s*yes\b": True,
            r"\bunauthorized\b": False,
            r"\bno\s+permission\b": False,
        }
        for pattern, status in auth_patterns.items():
            if re.search(pattern, user_message, re.IGNORECASE):
                self.target.authorized = status
                logger.info(f"Target authorization set to: {status}")
                break

        # Parse OS type
        os_keywords = {
            r"\bwindows\s*(\d+)": ("Windows", "os_version"),
            r"\bwindows\b": ("Windows", None),
            r"\blinux\b": ("Linux", None),
            r"\bubuntu\s+([\d.]+)": ("Linux", "os_version"),
            r"\bubuntu\b": ("Linux", None),
            r"\bcentos\b": ("Linux", None),
            r"\bdebian\b": ("Linux", None),
            r"\bmacos\b": ("macOS", None),
            r"\bmac\b": ("macOS", None),
            r"\bandroid\b": ("Android", None),
            r"\bios\b": ("iOS", None),
        }

        for pattern, (os_name, version_field) in os_keywords.items():
            match = re.search(pattern, user_message, re.IGNORECASE)
            if match:
                self.target.os_type = os_name
                if version_field and match.groups():
                    setattr(self.target, version_field, match.group(1))
                logger.info(f"OS identified: {os_name} {match.group(1) if match.groups() else ''}")
                break

        # Parse services
        service_keywords = {
            "ssh": 22,
            "rdp": 3389,
            "smb": 445,
            "http": 80,
            "https": 443,
            "ftp": 21,
            "telnet": 23,
            "mysql": 3306,
            "postgresql": 5432,
            "mongodb": 27017,
            "redis": 6379,
            "vnc": 5900,
            "nfs": 2049,
            "dns": 53,
            "smtp": 25,
        }

        for service, port in service_keywords.items():
            if service in user_message.lower():
                if service.upper() not in self.target.services:
                    self.target.services.append(service.upper())
                if port not in self.target.open_ports:
                    self.target.open_ports.append(port)
                logger.info(f"Service identified: {service} on port {port}")

        # Parse methodology answers
        if self.methodology:
            # Delivery methods
            delivery_patterns = ["exe", "powershell", "ps1", "dll", "batch", "bat", "macro"]
            for dm in delivery_patterns:
                if dm in user_message.lower():
                    self.methodology.delivery_method = dm.upper()

            # Callback types
            callback_patterns = ["reverse tcp", "reverse https", "reverse http", "bind shell"]
            for ct in callback_patterns:
                if ct in user_message.lower():
                    self.methodology.callback_type = ct.title()

            # Obfuscation
            if "obfuscation" in user_message.lower() or "encoding" in user_message.lower():
                if any(
                    word in user_message.lower() for word in ["yes", "true", "enable", "needed"]
                ):
                    self.methodology.obfuscation = True
                elif any(
                    word in user_message.lower() for word in ["no", "false", "disable", "none"]
                ):
                    self.methodology.obfuscation = False

            # Payload format
            format_patterns = [r"\bexe\b", r"\belf\b", r"\bapk\b", r"\bscript\b"]
            for fp in format_patterns:
                match = re.search(fp, user_message, re.IGNORECASE)
                if match:
                    self.methodology.payload_format = match.group().lower()

            # Network location
            network_patterns = ["internal", "dmz", "external"]
            for np in network_patterns:
                if np in user_message.lower():
                    self.target.network_location = np.title()

            # Capture other answers
            lines = user_message.split("\n")
            for line in lines:
                if ":" in line:
                    parts = line.split(":", 1)
                    key = parts[0].strip().lower()
                    val = parts[1].strip()
                    self.methodology.answers[key] = val

    def _reconnaissance_stage(self, user_message: str) -> str:
        """
        Stage 1: Ask for basic target information.

        NEVER skip this - always ask for:
        1. Target IP/hostname
        2. OS type
        3. Basic goal
        4. Authorization
        """

        if not self.target:
            self.target = TargetInfo()

        # If we have some info but not all, ask for what's missing
        missing_info = []

        if not self.target.ip_address and not self.target.hostname:
            missing_info.append("Target IP address or hostname")
        if not self.target.os_type:
            missing_info.append("Operating system (Windows, Linux, macOS, etc.)")
        if self.target.authorized is None:
            missing_info.append("Testing authorization (Is this your lab or authorized test?)")

        if missing_info:
            return (
                "I'll help you conduct a systematic penetration test. "
                "First, I need to establish the target and authorization:\n\n"
                "**Missing Information:**\n"
                + "\n".join(f"  • {item}" for item in missing_info)
                + "\n\n"
                "**Please provide:**\n"
                "1. Target IP address (e.g., 192.168.1.100)\n"
                "2. Operating system (Windows 10/11, Ubuntu 20.04, macOS, etc.)\n"
                "3. Confirmation that this is authorized testing (e.g., 'this is my lab')\n"
                "4. What's your access level? (No access, user account, admin, etc.)\n\n"
                "This information helps me determine the appropriate testing methodology."
            )

        # Block if explicitly not authorized
        if self.target.authorized is False:
            return (
                "⚠️ **PENETRATION TESTING BLOCKED** ⚠️\n\n"
                "I cannot assist with unauthorized penetration testing. "
                "Testing must only be performed on systems you own or have "
                "explicit, written permission to test."
            )

        # If we have basic info, move to next stage
        if self.target.ip_address:
            return self._enumerate_os_stage(user_message)

        return "Please provide the target IP address or hostname to begin."

    def _enumerate_os_stage(self, user_message: str) -> str:
        """
        Stage 2: Ask for detailed OS information.

        CRITICAL: Ask for version, architecture, patches before proceeding.
        """

        missing_details = []

        if not self.target.os_type:
            missing_details.append("Operating system type (Windows, Linux, macOS, etc.)")
        if not self.target.os_version:
            missing_details.append("OS version (e.g., Windows 10 21H2, Ubuntu 20.04 LTS)")

        if missing_details:
            return (
                f"Good, I have the target identified:\n\n"
                f"{self.target.to_summary()}\n\n"
                f"Now I need more OS-specific details:\n\n"
                + "\n".join(f"  • {item}" for item in missing_details)
                + "\n\n"
                "**Why this matters:**\n"
                "- Different OS versions have different vulnerabilities\n"
                "- Patch levels determine which CVEs are applicable\n"
                "- Architecture (x86/x64) affects payload format\n\n"
                "What OS version is your target running?"
            )

        # If we have OS info, move to service enumeration
        return self._enumerate_services_stage(user_message)

    def _enumerate_services_stage(self, user_message: str) -> str:
        """
        Stage 3: Ask for running services and open ports.

        CRITICAL: Don't skip this - need to know what's exposed before choosing exploit.
        """

        if not self.target:
            return "Target information lost. Please start over with target details."

        # Check if we have service info
        if not self.target.services and not self.target.open_ports:
            return (
                f"Target identified:\n{self.target.to_summary()}\n\n"
                f"**Service Enumeration Needed:**\n\n"
                f"To determine the best exploitation approach, I need to know:\n\n"
                f"1. **What services are running?**\n"
                f"   - Common services: SSH (22), RDP (3389), SMB (445), HTTP/HTTPS (80/443)\n"
                f"   - Database services: MySQL (3306), PostgreSQL (5432)\n"
                f"   - Other: FTP, Telnet, VNC, etc.\n\n"
                f"2. **Service versions** (if known):\n"
                f"   - E.g., 'Apache 2.4.41', 'OpenSSH 7.4', 'nginx 1.18'\n\n"
                f"3. **Can you scan the target?**\n"
                f"   - If yes, run: `nmap -sV -sC {self.target.ip_address}`\n"
                f"   - Share the results with me\n\n"
                f"Service enumeration is critical for selecting the right exploit."
            )

        # We have some service info
        return (
            f"Target and services identified:\n{self.target.to_summary()}\n\n"
            f"**Let me verify the service information:**\n\n"
            f"Are these all the services you found? Any additional details:\n"
            f"- Service versions?\n"
            f"- Any custom or unusual services?\n"
            f"- Any firewall or network restrictions?\n\n"
            f"This helps me narrow down the most effective exploitation vectors."
        )

    def _methodology_selection_stage(self, user_message: str) -> str:
        """
        Stage 4: Select exploitation methodology.

        CRITICAL: Ask systematic questions BEFORE generating any code/payload.
        """

        # Initialize methodology if needed
        if not self.methodology:
            self.methodology = ExploitMethodology()

        # Determine which question set to use based on target and services
        questions = []

        # 1. Basic methodology questions (always needed)
        if not self.methodology.delivery_method:
            questions.append(
                "1. What delivery method do you prefer? (EXE, PowerShell, DLL, batch, macro?)"
            )
        if not self.methodology.callback_type:
            questions.append(
                "2. What callback type should we use? (Reverse TCP, Reverse HTTPS, Bind shell?)"
            )
        if self.methodology.obfuscation is None:
            questions.append("3. Is obfuscation/AV evasion needed? (yes/no)")
        if not self.target.network_location:
            questions.append("4. Where is the target located? (Internal, DMZ, External?)")

        # 2. OS-specific or service-specific questions
        if self.target.os_type == "Windows":
            if "windows_version" not in self.methodology.answers:
                questions.append("5. Specific Windows version? (7, 8, 10, Server 2016/2019/2022?)")
            if "lhost" not in self.methodology.answers:
                questions.append("6. LHOST/LPORT for your attacker machine?")

        elif "SSH" in self.target.services:
            if "ssh_auth" not in self.methodology.answers:
                questions.append("5. SSH authentication method? (Password, key-based, none?)")
            if "can_upload" not in self.methodology.answers:
                questions.append("6. Can you upload files to the target? (yes/no)")

        elif "SMB" in self.target.services:
            if "smb_version" not in self.methodology.answers:
                questions.append("5. SMB version? (v1, v2, v3?)")
            if "credentials" not in self.methodology.answers:
                questions.append("6. Available credentials? (none, partial, full?)")

        if questions:
            return (
                f"**Target Summary:**\n{self.target.to_summary()}\n\n"
                f"**Methodology Selection**\n\n"
                f"To recommend the best approach, please answer these methodology questions:\n\n"
                + "\n".join(questions)
                + "\n\n"
                "**Why these matter:**\n"
                "- Delivery method determines how we get the payload to the target\n"
                "- Callback type affects how we maintain the connection\n"
                "- Obfuscation impacts AV/EDR evasion\n"
                "- Network location affects connectivity and firewall rules\n\n"
                "Please provide these details to continue."
            )

        # If we have all methodology info, move to exploitation
        return self._exploitation_stage(user_message)

    def _exploitation_stage(self, user_message: str) -> str:
        """
        Stage 5: Generate and explain exploitation strategy.

        CRITICAL: Only generate code AFTER:
        - All target info is complete
        - Methodology questions are answered
        - Exploitation path is explained

        This stage explains the methodology and generates code ONLY when appropriate.
        """

        if not self.target or not self.methodology:
            return "Target or methodology information incomplete. Please start over."

        # Use LLM to reason through the exploitation strategy
        strategy_prompt = self._build_strategy_prompt()

        try:
            ai_strategy = self.llm_client.generate(strategy_prompt)

            logger.info(f"AI Strategy Generated for {self.target.ip_address}")

            # Add context header
            response = (
                f"**Exploitation Strategy for Target: {self.target.ip_address}**\n\n"
                f"{self.target.to_summary()}\n\n"
                f"**Chosen Methodology:**\n"
                f"  • Delivery: {self.methodology.delivery_method}\n"
                f"  • Callback: {self.methodology.callback_type}\n"
                f"  • Payload Format: {self.methodology.payload_format}\n"
                f"  • Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}\n\n"
                f"---\n\n"
                f"{ai_strategy}"
            )

            # Check if AI suggested a command and execute it if authorized
            command_to_run = self._extract_command_from_response(ai_strategy)
            execution_output = ""
            if command_to_run and self.target.authorized and self.direct_executor:
                logger.info(f"Identified command to execute: {command_to_run}")
                try:
                    exit_code, output = self.direct_executor.execute_metasploit_command(
                        command_to_run, show_terminal=True
                    )
                    execution_output = (
                        f"\n\n**Execution Output for `{command_to_run}`:**\n```\n{output}\n```"
                    )
                except Exception as e:
                    execution_output = f"\n\n**Error executing command:** {str(e)}"

            return response + execution_output

        except Exception as e:
            logger.error(f"Failed to generate exploitation strategy: {e}")
            return (
                "Target and methodology identified, but I encountered an error "
                "generating the strategy.\n\n"
                f"Error: {str(e)}\n\n"
                "Please try again or rephrase your request."
            )

    def _build_strategy_prompt(self) -> str:
        """Build the exploitation strategy prompt for the LLM."""
        services_str = ", ".join(self.target.services) if self.target.services else "None"
        ports_str = (
            ", ".join(map(str, self.target.open_ports)) if self.target.open_ports else "None"
        )
        cves_str = ", ".join(self.target.cves) if self.target.cves else "None identified"

        prompt = f"""You are an expert pentester. Explain the methodology for this target:

**Target Information:**
- IP: {self.target.ip_address}
- OS: {self.target.os_type} {self.target.os_version or ''}
- Architecture: {self.target.architecture or 'Unknown'}
- Services: {services_str}
- Open Ports: {ports_str}
- Network Location: {self.target.network_location or 'Unknown'}
- Access Level: {self.target.access_level or 'Unauthenticated'}

**Service Versions:**
{self.target.service_versions or 'None provided'}

**Known Vulnerabilities/CVEs:**
{cves_str}

**Methodology Requirements:**
- Delivery Method: {self.methodology.delivery_method}
- Callback Type: {self.methodology.callback_type}
- Payload Format: {self.methodology.payload_format}
- Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}

**Your Task:**
1. Analyze the target and identify the BEST exploitation vectors
2. Explain WHY this method is most effective for this specific configuration
3. Describe the exploitation chain step-by-step
4. Identify risk factors (AV/EDR, detection, stability)
5. Provide specific commands or code ONLY IF this is a standard exploit
6. For Metasploit exploits, provide the exact module name and configuration options
7. For custom exploits, explain what the code will do

**Output Format:**
**Exploitation Analysis:**
[Your detailed reasoning about why this approach is best for this target]

**Recommended Exploit Chain:**
[Step-by-step breakdown of the exploitation process]

**Implementation:**
[If using a known exploit framework like Metasploit, provide exact commands]
[If custom code is needed, explain what the code will accomplish]
[Only generate actual code if you're confident it will work for this target]

**Risk Assessment:**
[AV/EDR detection risk, network monitoring, stability concerns]

**Post-Exploitation:**
[Suggested next steps once access is gained]

CRITICAL: Do NOT generate code just to generate code. Only provide
implementation details when you have high confidence the exploit will work
for this specific target configuration."""

        return prompt

    def _extract_command_from_response(self, response: str) -> Optional[str]:
        """Extract a command from the AI response."""
        # Look for code blocks with msfconsole or nmap
        code_blocks = re.findall(
            r"```(?:bash|powershell|msfconsole)?\s*(.*?)\s*```", response, re.DOTALL
        )
        for block in code_blocks:
            lines = block.strip().split("\n")
            for line in lines:
                line = line.strip()
                if (
                    line.startswith("msfconsole")
                    or line.startswith("nmap")
                    or line.startswith("msfvenom")
                ):
                    # Validate syntax roughly
                    if "auxiliary/sca/nner" in line:
                        line = line.replace("auxiliary/sca/nner", "auxiliary/scanner")
                    if "socket.so/cket" in line:
                        line = line.replace("socket.so/cket", "socket.socket")
                    return line
        return None

    def update_target_info(self, field: str, value: Any) -> None:
        """
        Update specific target field.

        Args:
            field: Field name to update
            value: New value
        """
        if not self.target:
            self.target = TargetInfo()

        if hasattr(self.target, field):
            setattr(self.target, field, value)
            logger.info(f"Updated target {field}: {value}")

    def update_methodology(self, field: str, value: Any) -> None:
        """
        Update specific methodology field.

        Args:
            field: Field name to update
            value: New value
        """
        if not self.methodology:
            self.methodology = ExploitMethodology()

        if hasattr(self.methodology, field):
            setattr(self.methodology, field, value)
            logger.info(f"Updated methodology {field}: {value}")

    def get_target_summary(self) -> str:
        """Get a formatted summary of current target information."""
        if not self.target:
            return "No target information available."

        return f"**Target Summary:**\n{self.target.to_summary()}"

    def get_methodology_summary(self) -> str:
        """Get a formatted summary of current methodology."""
        if not self.methodology:
            return "No methodology selected yet."

        parts = []

        if self.methodology.delivery_method:
            parts.append(f"  • Delivery: {self.methodology.delivery_method}")
        if self.methodology.callback_type:
            parts.append(f"  • Callback: {self.methodology.callback_type}")
        if self.methodology.payload_format:
            parts.append(f"  • Payload: {self.methodology.payload_format}")
        if self.methodology.obfuscation is not None:
            parts.append(f"  • Obfuscation: {'Yes' if self.methodology.obfuscation else 'No'}")

        return "\n".join(parts) if parts else "No methodology details set yet"
