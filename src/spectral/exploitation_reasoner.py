"""
Exploitation Reasoner - Semantic reasoning for autonomous exploit selection.

Analyzes target information and reasons about the best exploitation approach.
Replaces hardcoded methodology with intelligent decision-making.
"""

import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from spectral.llm_client import LLMClient

logger = logging.getLogger(__name__)


class ExploitCategory(Enum):
    """Categories of exploits available."""

    REMOTE_CODE_EXECUTION = "remote_code_execution"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    CREDENTIAL_GATHERING = "credential_gathering"
    LATERAL_MOVEMENT = "lateral_movement"
    PERSISTENCE = "persistence"
    DATA_EXFILTRATION = "data_exfiltration"
    DENIAL_OF_SERVICE = "denial_of_service"
    INFORMATION_DISCLOSURE = "information_disclosure"


class AttackComplexity(Enum):
    """Complexity levels for attacks."""

    LOW = "low"  # Simple exploits, well-known vulnerabilities
    MEDIUM = "medium"  # Multi-step attacks, some customization
    HIGH = "high"  # Complex chains, advanced techniques
    EXPERT = "expert"  # Custom exploits, cutting-edge techniques


class RiskLevel(Enum):
    """Risk levels for attacks."""

    MINIMAL = "minimal"  # Very low detection probability
    LOW = "low"  # Low detection probability
    MEDIUM = "medium"  # Moderate detection probability
    HIGH = "high"  # High detection probability
    EXTREME = "extreme"  # Very high detection probability


@dataclass
class ExploitOption:
    """An exploit option with reasoning details."""

    name: str
    category: ExploitCategory
    complexity: AttackComplexity
    risk_level: RiskLevel
    description: str
    success_probability: float  # 0.0 to 1.0
    prerequisites: List[str] = field(default_factory=list)
    post_exploitation: List[str] = field(default_factory=list)
    modules: List[str] = field(default_factory=list)  # Metasploit modules
    commands: List[str] = field(default_factory=list)  # Raw commands
    reasoning: str = ""  # Why this exploit is recommended
    alternatives: List[str] = field(default_factory=list)  # Alternative approaches


@dataclass
class ExploitationPlan:
    """Complete exploitation plan with reasoning."""

    target_summary: str
    primary_attack_vector: str
    attack_chain: List[ExploitOption]
    fallback_strategies: List[ExploitOption]
    risk_assessment: Dict[str, str]
    expected_outcomes: List[str]
    post_exploitation_steps: List[str]
    cleanup_requirements: List[str]
    reasoning_summary: str


class ExploitationReasoner:
    """
    Semantic reasoning for exploit selection and planning.

    Features:
    - Analyzes target information semantically
    - Reasons about attack vectors based on context
    - Considers risk vs reward trade-offs
    - Generates exploitation plans with rationale
    - Adapts strategies based on available information
    """

    def __init__(self, llm_client: Optional[LLMClient] = None):
        """
        Initialize the exploitation reasoner.

        Args:
            llm_client: LLM client for semantic analysis
        """
        self.llm_client = llm_client
        self.attack_knowledge = self._load_attack_knowledge()

        logger.info("ExploitationReasoner initialized")

    def reason_about_target(
        self,
        target_info: Dict[str, Any],
        available_credentials: Optional[List[Dict[str, str]]] = None,
        network_context: Optional[str] = None,
    ) -> ExploitationPlan:
        """
        Reason about exploitation approach for a given target.

        Args:
            target_info: Target information dictionary
            available_credentials: Available credentials for the target
            network_context: Network context (internal, DMZ, external)

        Returns:
            ExploitationPlan with detailed reasoning
        """
        logger.info(
            f"Reasoning about exploitation for target: {target_info.get('ip', 'unknown')}"
        )

        # If we have an LLM, use it for advanced reasoning
        if self.llm_client:
            return self._reason_with_llm(
                target_info, available_credentials, network_context
            )
        else:
            return self._reason_with_heuristics(
                target_info, available_credentials, network_context
            )

    def _reason_with_llm(
        self,
        target_info: Dict[str, Any],
        available_credentials: Optional[List[Dict[str, str]]] = None,
        network_context: Optional[str] = None,
    ) -> ExploitationPlan:
        """Use LLM for semantic reasoning about exploitation."""

        # Build reasoning prompt
        prompt = self._build_reasoning_prompt(
            target_info, available_credentials, network_context
        )

        try:
            response = self.llm_client.generate(prompt, max_tokens=2000)

            # Parse the response into an ExploitationPlan
            return self._parse_reasoning_response(response, target_info)

        except Exception as e:
            logger.error(f"LLM reasoning failed: {e}, falling back to heuristics")
            return self._reason_with_heuristics(
                target_info, available_credentials, network_context
            )

    def _build_reasoning_prompt(
        self,
        target_info: Dict[str, Any],
        available_credentials: Optional[List[Dict[str, str]]] = None,
        network_context: Optional[str] = None,
    ) -> str:
        """Build the reasoning prompt for the LLM."""

        credentials_text = ""
        if available_credentials:
            cred_details = []
            for cred in available_credentials:
                cred_details.append(
                    f"- {cred.get('username', 'unknown')}: {cred.get('password', 'unknown')}"
                )
            credentials_text = "\n".join(cred_details)

        prompt = f"""You are an expert penetration tester. Analyze this target and reason about the best exploitation approach.

**Target Information:**
- IP Address: {target_info.get('ip', 'unknown')}
- Hostname: {target_info.get('hostname', 'unknown')}
- Operating System: {target_info.get('os_type', 'unknown')} {target_info.get('os_version', '')}
- Architecture: {target_info.get('architecture', 'unknown')}
- Network Location: {network_context or target_info.get('network_location', 'unknown')}

**Services and Ports:**
{self._format_services(target_info)}

**Service Versions:**
{self._format_service_versions(target_info)}

**Available Credentials:**
{credentials_text or "None provided"}

**Known Vulnerabilities:**
{self._format_vulnerabilities(target_info)}

**Your Task:**
1. Analyze the attack surface and identify the most promising exploitation vectors
2. Consider the specific target configuration, not generic approaches
3. Reason about success probability, detection risk, and operational impact
4. Plan a complete attack chain from initial access to post-exploitation
5. Consider network context and any available credentials

**Output Format:**
Analyze this target and provide a detailed exploitation plan with reasoning.

**PRIMARY ATTACK VECTOR:**
[What is the most promising initial access method? Why?]

**EXPLOITATION PLAN:**
[Step-by-step breakdown of the attack chain]

**RISK ASSESSMENT:**
[Detection probability, stability concerns, network monitoring]

**SUCCESS PROBABILITY:**
[Your estimate of success for this approach]

**POST-EXPLOITATION:**
[What can be accomplished after gaining access]

**FALLBACK STRATEGIES:**
[Alternative approaches if the primary vector fails]

Be specific to this target's configuration and avoid generic advice."""

        return prompt

    def _format_services(self, target_info: Dict[str, Any]) -> str:
        """Format services for the prompt."""
        services = target_info.get("services", [])
        ports = target_info.get("open_ports", [])

        if not services and not ports:
            return "No service information provided"

        service_lines = []
        for i, service in enumerate(services):
            port = ports[i] if i < len(ports) else "unknown"
            service_lines.append(f"- {service} on port {port}")

        return (
            "\n".join(service_lines)
            if service_lines
            else "No specific services identified"
        )

    def _format_service_versions(self, target_info: Dict[str, Any]) -> str:
        """Format service versions for the prompt."""
        versions = target_info.get("service_versions", {})

        if not versions:
            return "No version information provided"

        version_lines = []
        for service, version in versions.items():
            version_lines.append(f"- {service}: {version}")

        return "\n".join(version_lines)

    def _format_vulnerabilities(self, target_info: Dict[str, Any]) -> str:
        """Format vulnerabilities for the prompt."""
        cves = target_info.get("cves", [])
        vulns = target_info.get("known_vulnerabilities", [])

        all_vulns = cves + vulns

        if not all_vulns:
            return "No specific vulnerabilities identified"

        vuln_lines = []
        for vuln in all_vulns:
            vuln_lines.append(f"- {vuln}")

        return "\n".join(vuln_lines)

    def _parse_reasoning_response(
        self, response: str, target_info: Dict[str, Any]
    ) -> ExploitationPlan:
        """Parse LLM response into an ExploitationPlan."""

        # This is a simplified parser - in a real implementation,
        # you'd want more sophisticated parsing

        # Create basic plan structure
        plan = ExploitationPlan(
            target_summary=target_info.get("ip", "unknown"),
            primary_attack_vector="See reasoning below",
            attack_chain=[],
            fallback_strategies=[],
            risk_assessment={"overall": "See analysis"},
            expected_outcomes=["Initial access", "System reconnaissance"],
            post_exploitation_steps=["Privilege escalation", "Persistence"],
            cleanup_requirements=["Session cleanup"],
            reasoning_summary=response,
        )

        return plan

    def _reason_with_heuristics(
        self,
        target_info: Dict[str, Any],
        available_credentials: Optional[List[Dict[str, str]]] = None,
        network_context: Optional[str] = None,
    ) -> ExploitationPlan:
        """Use heuristic reasoning when LLM is not available."""

        # Basic attack vector selection based on target characteristics
        services = target_info.get("services", [])
        os_type = target_info.get("os_type", "").lower()
        has_creds = bool(available_credentials)

        # Primary attack vector determination
        if "ssh" in [s.lower() for s in services] and has_creds:
            primary_vector = "SSH credential-based access"
        elif "smb" in [s.lower() for s in services] and has_creds:
            primary_vector = "SMB credential-based access"
        elif "rdp" in [s.lower() for s in services] and has_creds:
            primary_vector = "RDP credential-based access"
        elif os_type == "windows":
            primary_vector = "Windows service exploitation"
        elif os_type == "linux":
            primary_vector = "Linux service exploitation"
        else:
            primary_vector = "Service enumeration and vulnerability scanning"

        # Build basic attack chain
        attack_chain = []
        fallback_strategies = []

        # Add appropriate exploits based on context
        if has_creds:
            if "ssh" in [s.lower() for s in services]:
                attack_chain.append(
                    ExploitOption(
                        name="SSH Brute Force",
                        category=ExploitCategory.REMOTE_CODE_EXECUTION,
                        complexity=AttackComplexity.LOW,
                        risk_level=RiskLevel.LOW,
                        description="Use provided credentials via SSH",
                        success_probability=0.8,
                        reasoning="Credentials provided - high success probability",
                    )
                )

        # Always include basic enumeration as first step
        attack_chain.append(
            ExploitOption(
                name="Service Enumeration",
                category=ExploitCategory.INFORMATION_DISCLOSURE,
                complexity=AttackComplexity.LOW,
                risk_level=RiskLevel.MINIMAL,
                description="Detailed service and version enumeration",
                success_probability=0.95,
                commands=["nmap -sV -sC <target_ip>"],
                reasoning="Essential first step for any pentest",
            )
        )

        # Create the plan
        plan = ExploitationPlan(
            target_summary=target_info.get("ip", "unknown"),
            primary_attack_vector=primary_vector,
            attack_chain=attack_chain,
            fallback_strategies=fallback_strategies,
            risk_assessment={
                "detection": "Low if credentials are valid" if has_creds else "Medium",
                "stability": "High for credential-based attacks",
            },
            expected_outcomes=["Initial access", "Service information"],
            post_exploitation_steps=["Privilege escalation", "Lateral movement"],
            cleanup_requirements=["Remove any uploaded files"],
            reasoning_summary=f"Heuristic reasoning for {primary_vector} targeting {os_type} system",
        )

        return plan

    def _load_attack_knowledge(self) -> Dict[str, Any]:
        """Load knowledge base of attacks and exploits."""
        return {
            "windows_exploits": {
                "eternalblue": {
                    "cve": "MS17-010",
                    "services": ["smb"],
                    "versions": ["Windows 7/2008R2"],
                    "risk": "HIGH",
                    "modules": ["exploit/windows/smb/ms17_010_eternalblue"],
                },
                "badpotato": {
                    "service": "Print Spooler",
                    "versions": ["Windows 10/2019/2022"],
                    "risk": "HIGH",
                    "modules": ["exploit/windows/local/bad_potato"],
                },
                "winrm_rce": {
                    "service": "WinRM",
                    "port": 5985,
                    "risk": "MEDIUM",
                    "modules": ["exploit/winrm/winrm_script_exec"],
                },
            },
            "linux_exploits": {
                "dirty_cow": {
                    "cve": "CVE-2016-5195",
                    "versions": ["Kernel < 4.8.3"],
                    "risk": "MEDIUM",
                    "modules": ["exploit/linux/local/dirtycow"],
                },
                "ssh_bruteforce": {
                    "service": "SSH",
                    "port": 22,
                    "risk": "LOW",
                    "modules": ["auxiliary/scanner/ssh/ssh_login"],
                },
            },
            "network_services": {
                "ftp": {"port": 21, "risk": "LOW"},
                "telnet": {"port": 23, "risk": "HIGH"},
                "smtp": {"port": 25, "risk": "MEDIUM"},
                "dns": {"port": 53, "risk": "MEDIUM"},
                "http": {"port": 80, "risk": "MEDIUM"},
                "https": {"port": 443, "risk": "MEDIUM"},
                "rdp": {"port": 3389, "risk": "MEDIUM"},
                "smb": {"port": 445, "risk": "HIGH"},
                "ssh": {"port": 22, "risk": "LOW"},
                "mysql": {"port": 3306, "risk": "MEDIUM"},
                "postgresql": {"port": 5432, "risk": "MEDIUM"},
                "redis": {"port": 6379, "risk": "HIGH"},
            },
        }

    def get_exploit_recommendations(
        self, target_info: Dict[str, Any], max_risk: RiskLevel = RiskLevel.HIGH
    ) -> List[ExploitOption]:
        """
        Get exploit recommendations for a target.

        Args:
            target_info: Target information
            max_risk: Maximum acceptable risk level

        Returns:
            List of recommended exploits
        """
        recommendations = []

        services = target_info.get("services", [])
        os_type = target_info.get("os_type", "").lower()

        # Get OS-specific exploits
        if os_type == "windows":
            windows_exploits = self.attack_knowledge.get("windows_exploits", {})
            for exploit_name, exploit_info in windows_exploits.items():
                risk_level = RiskLevel(exploit_info.get("risk", "MEDIUM").lower())
                if self._risk_level_to_enum(risk_level) <= max_risk:
                    # Check if exploit applies to target
                    if self._exploit_applies_to_target(exploit_info, target_info):
                        recommendations.append(
                            ExploitOption(
                                name=exploit_name,
                                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                                complexity=AttackComplexity.MEDIUM,
                                risk_level=risk_level,
                                description=exploit_info.get("description", ""),
                                success_probability=0.7,
                                modules=exploit_info.get("modules", []),
                                reasoning=f"Applicable to {os_type} target",
                            )
                        )

        elif os_type == "linux":
            linux_exploits = self.attack_knowledge.get("linux_exploits", {})
            for exploit_name, exploit_info in linux_exploits.items():
                risk_level = RiskLevel(exploit_info.get("risk", "MEDIUM").lower())
                if self._risk_level_to_enum(risk_level) <= max_risk:
                    if self._exploit_applies_to_target(exploit_info, target_info):
                        recommendations.append(
                            ExploitOption(
                                name=exploit_name,
                                category=ExploitCategory.REMOTE_CODE_EXECUTION,
                                complexity=AttackComplexity.MEDIUM,
                                risk_level=risk_level,
                                description=exploit_info.get("description", ""),
                                success_probability=0.6,
                                modules=exploit_info.get("modules", []),
                                reasoning=f"Applicable to {os_type} target",
                            )
                        )

        # Add service-based exploits
        for service in services:
            service_lower = service.lower()
            if service_lower in self.attack_knowledge.get("network_services", {}):
                service_info = self.attack_knowledge["network_services"][service_lower]
                risk_level = RiskLevel(service_info.get("risk", "MEDIUM").lower())

                if self._risk_level_to_enum(risk_level) <= max_risk:
                    recommendations.append(
                        ExploitOption(
                            name=f"{service_lower}_exploitation",
                            category=ExploitCategory.REMOTE_CODE_EXECUTION,
                            complexity=AttackComplexity.LOW,
                            risk_level=risk_level,
                            description=f"Exploit {service} service",
                            success_probability=0.5,
                            modules=[
                                f"auxiliary/scanner/{service_lower}/{service_lower}_login"
                            ],
                            reasoning=f"Standard {service} exploitation",
                        )
                    )

        # Sort by success probability
        recommendations.sort(key=lambda x: x.success_probability, reverse=True)

        return recommendations

    def _exploit_applies_to_target(
        self, exploit_info: Dict[str, Any], target_info: Dict[str, Any]
    ) -> bool:
        """Check if an exploit applies to the target."""
        # Check service requirements
        if "services" in exploit_info:
            target_services = [s.lower() for s in target_info.get("services", [])]
            required_services = [s.lower() for s in exploit_info["services"]]
            if not any(service in target_services for service in required_services):
                return False

        # Check version requirements
        if "versions" in exploit_info:
            target_version = target_info.get("os_version", "").lower()
            required_versions = [v.lower() for v in exploit_info["versions"]]
            if not any(v in target_version for v in required_versions):
                return False

        return True

    def _risk_level_to_enum(self, risk_level: RiskLevel) -> RiskLevel:
        """Convert risk level string to enum."""
        return risk_level
